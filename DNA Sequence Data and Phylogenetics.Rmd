---
title: "DNA Sequence Data and Phylogenetics"
author: "Alexandra Boville"
date: "2024-04-24"
output: html_document
---

## Starting Steps: Reading in DNA Code and Preliminary Data

### Load in Necessary Packages
```{r}
InstallPackages = FALSE
if (InstallPackages) {
    if (!requireNamespace("BiocManager", quietly=TRUE)) 
        install.packages("BiocManager")
    BiocManager::install("msa")
    install.packages("adegenet")
    install.packages("ape")
    BiocManager::install("Biostrings")
    BiocManager::install("ggtree")
    install.packages("ggplot2")
    install.packages("ips")
    install.packages("bios2mds")
    install.packages("haplotypes")
    install.packages("pegas")
    install.packages("phytools")
    install.packages("stats")
    install.packages("treeio") }
```

```{r}
library(adegenet)
library(ape)
library(Biostrings)
library(ggtree)
library(ggplot2)
library(stats)
library(ips)
library(msa)
library (spider)
```

### Read in DNA Code. Uses {ape} function to import fasta files as a DNAbin, a filetype used in most {ape} functions.
```{r}
Ostrich_dna <- read.dna("https://raw.githubusercontent.com/allyboville3/Collaborative-Data-Science-Project/main/Aves%20FASTA%20Files/Struthio_camelus.fasta", format = "fasta")

# This creates a specific structure called a DNAbin in {ape}. We can see this by checking the class.

class (Ostrich_dna)
```

### Preliminary data/looking

Use {ape} to gather some other information:
This calculates the frequency of the four nucleotides in the FASTA file. This can be useful for verifying normal expected ranges. 
```{r}
base.freq(Ostrich_dna)
```

This calculates the GC content, which is useful for determining quality, length of certain coding regions, and more. 
```{r}
GC.content(Ostrich_dna)
```

## Trimming and Preparing Data
This is another way to import data. It imports as a different file type, Biostrings, and is under the {Biostrings} package. 
```{r}
MySeq <- readDNAStringSet("https://raw.githubusercontent.com/allyboville3/Collaborative-Data-Science-Project/main/Aves_cytB.fas")
```

Using the `msa()` function in the {msa} package aligns all samples to the same length by the ClustalW algorithm and stores them as a DNAStringSet object.
```{r}
msa(MySeq)
```
Let's look at it!
```{r}
print(MySeq)
```

Using the `as.DNAbin()` function from {ape} allows us to store these multiple alignments as a DNAbin object. We need a DNAbin object going forward to use many functions, including those from {ape}
```{r}
SeqBin <- as.DNAbin(MySeq)
```

Trim ends. We do not really use this function with our data because it is already trimmed. You need either the quality of the code or the primer information to trim ends of DNA. 
```{r}
SeqBin <- trimEnds(as.matrix(SeqBin))
```


## Phylogenetics

Starting Work
```{r}
nbinmat<-as.matrix(labels(SeqBin)) #extraction of the sample names
class(SeqBin) #just checking to make sure we have the right one.
dnbin<-dist.dna(SeqBin, model = "K80") #computing distance by ape package with K80 model derived by Kimura (1980)
tree<-nj(dnbin) # this function from {ape} estimates the neighbor-joining tree estimation. It uses Saitou and Nei (1987)
```

Plot a phylogenetic tree using the `msaplot()` command from {ggtree} along with various aesthetics from {ggplot2}
```{r}
#colors can be changes at will, of course!
ggt <- ggtree(tree, cex = 0.8, aes(color = branch.length)) +
  scale_color_continuous(high = "skyblue",low = "black") + #this colors the scale of the branches
  geom_tiplab(align = TRUE, size = 5) + #changes size and alignment of branches
  theme(legend.position = "right") + #positions legend
  geom_treescale(y = -5, color = "red", fontsize = 3) #adds scale for tree at bottom
  msaplot(ggt, SeqBin, offset = 0.25, width = 0.75, height = 0.5) #Offset, width, and height adjusts the sequence illustration to right of the tree
  color = c(rep("rosybrown", 1), rep("sienna1", 1),
            rep("lightgoldenrod1", 1), rep("lightskyblue1", 1), rep("palegreen", 1)) #changes color of bases. May need to add additional colors if other unknown variables exist (W,-, etc) or remove color if sequence is complete
```

There are other ways to represent trees that show different things:
```{r}
#Second tree, this one an unrooted phylogeny
ggtree(tree, aes(color = branch.length)) + geom_tiplab(size = 7) + layout_inward_circular()
#function `layout_inward_circular changes the shape
```

## More analysis
Calculating Genetic Distance demonstrates that our assumption that the unknown is most closely related to *Dinornis giganteus* is correct. 
```{r}
dist.gene((as.matrix(SeqBin)), method = "pairwise", pairwise.deletion = FALSE,
          variance = FALSE)
```

Is it monophyletic?

```{r}
is.monophyletic(tree, c("Dinornis giganteus", "Unknown Species"))
is.monophyletic(tree, c("Dinornis giganteus", "Struthio camelus"))

```


## Tree Rooting

```{r}
# plot tree
plot.phylo(tree, main="Aves (Palaeognathae) Phylogenetic Tree", 
            type = "unrooted", 
            use.edge.length = F)

# add label
mtext(text = "Unrooted Tree - No branch Lengths")
```

```{r}
# plot tree
plot.phylo(tree, main= "Aves (Palaeognathae) Phylogenetic Tree", 
            use.edge.length = F)

# add label
mtext(text = "Rooted Tree - No branch Lengths")
```


```{r}
# plot tree
plot.phylo(tree, main="Aves (Palaeognathae) Phylogenetic Tree", 
            use.edge.length = T)

# add label
mtext(text = "Rooted Tree - With Branch Lengths")
```



## Haplotypes and Heatmaps

We used the data from the original paper, because the above data covered multiple species and was not appropriate for haplotype studies. 
```{r}
d <- read.dna("https://raw.githubusercontent.com/electrickearns/ada-2024-notes/main/pone.0243927.s002.fas", format = "fas")
class(d)
```

After, 

```{r}
an<-as.alignment(d)  #converting DNAbin to alignment format
nm<-as.matrix(an)       #converting alignment to matrix
sat2 <- NULL
for (i in 1:nrow(nm)) {
  sat2[i] <- paste(nm[i, ], collapse="")
}

sat2 <- toupper(sat2) #converts all letters to uppercase
sat3 <- unique(sat2) #gives only unique sequences from all sequences
sat3#that is, it gives complete sequences of haplotypes (20x373).
hfreq <- NULL
for (i in 1:length(sat3)) {
  hcount = 0
  s3 <- sat3[i]
  for (j in 1:length(sat2)) {
    s2 <- sat2[j]
    if (s3 == s2) {
      hcount <- (hcount + 1) #counts the number of individuals with the same haplotype sequence. 
      #print(paste(i, "yes", hcount))
    }
    #print(s2)
  }
  hname<-(paste("H",i, sep =""))
  hfreq[i] <- hcount
  #print(paste(hname, hcount, collapse = ""))
}   #haplotype frequency in the all samples

len <- nchar(sat3[1]) #assume all have same length!!!
cnt <- 1
sat4 = list()
for (j in 1:len) {
  same <- TRUE
  first <- substr(sat3[1], j, j)
  for (i in 2:length(sat3)) {
    ch1 <- substr(sat3[i], j, j)
    if (first != ch1) {
      str <- paste(j, first, ch1)
      print(str)
      same <- FALSE
      break
    }
  }
  if (!same) {
    ss <- NULL
    for (i in 1:length(sat3)) {
      ss <- paste(ss, substr(sat3[i], j, j), sep="")
    }
    sat4[cnt] <- ss
    cnt <- cnt + 1
  }
}#it gives the mutation points and the nucleotide substitutions

len <- nchar(sat3[1]) #assume all have same length!!!
cnt <- 1
sat5 = list() 
for (j in 1:len) { #scan all columnns and if all elements are the same do not copy
  same <- TRUE
  first <- substr(sat3[1], j, j)
  scol <- first
  for (i in 2:length(sat3)) {
    ch1 <- substr(sat3[i], j, j)
    scol <- paste(scol, ch1, sep="")
    if (first != ch1) {
      str <- paste(j, first, ch1)
      #print(str)
      same <- FALSE
      #break
    }
  }
  if (!same) {
    scol <- paste("V_", cnt, " ", scol, sep="")
    ss <- NULL
    for (i in 1:length(sat3)) {
      ss <- paste(ss, substr(sat3[i], j, j), sep="")
    } 
    sat5[cnt] <- ss
    cnt <- cnt + 1
  }
}

sat6 <- as.matrix(sat5)
mat6 = matrix(nrow=nrow(sat6), ncol=nchar(sat6[1]))
for (i in 1:nrow(mat6)) {
  s <- as.vector(strsplit(as.character(sat5[i]), ""))
  for (j in 1:ncol(mat6)) {
    mat6[i, j] <- as.character(s[[1]][j])
  }
}
mat7 <- t(mat6) #sequences of haplotypes and variable sites matrix (20x41)
write.table(mat7,file="mat7.txt", quote=FALSE, sep="\t")
hname<-paste("H", 1:nrow(mat7), sep = "")
rownames(mat7)=hname
write.table(mat7,file="mat7.txt", quote=FALSE, sep="\t") 

str4 <- NULL
str4[1] <- paste(mat7[1, ], collapse="")
for (i in 2:nrow(mat7)) {
  tmp <- NULL
  for (j in 1:ncol(mat7)) {
    chr = "."
    if(mat7[i, j] != mat7[1, j]) chr = mat7[i, j]
    tmp <- paste(tmp, chr, sep="")
  }
  str4[i] <- paste(tmp, collapse="")
}
nchar(str4[1]) #confirmation of number of variable sites
mstr4<-as.matrix(str4)
rownames(mstr4)<-hname
colnames(mstr4)<-paste("sequences length","(", ncol(mat7), "base pairs", ")")
pct<-round((as.matrix(hfreq)*100/colSums(as.matrix(hfreq))), 2)
colnames(pct)<-c("pct")
cmstr4<-as.data.frame(cbind(mstr4, hfreq, pct))
cmstr4
write.table(cmstr4,file="cmstr4.txt", quote=FALSE, sep="\t") 
```


Create the heatmap!
```{r}
sat2 <- NULL
for (i in 1:nrow(nm)) {
  sat2[i] <- paste(nm[i, ], collapse="")
}

sat2 <- toupper(sat2)
sat3 <- unique(sat2)
comat = matrix(nrow=length(sat3), ncol=length(sat3))
for (i in 1:length(sat3)) { 
  si <- sat3[i]
  for (j in 1:length(sat3)) { 
    sj <- sat3[j]
    difcnt = 0
    s1 = as.vector(strsplit(as.character(si), ""))
    s2 = as.vector(strsplit(as.character(sj), ""))
    for (k in 1:length(s1[[1]])) {
      if (s1[[1]][k] != s2[[1]][k]) {
        difcnt = difcnt + 1
      }
      comat[i, j] = difcnt
      #print(paste(i, " ", j, " ", difcnt))
    }
  }
}
comat	#is Hamming distance matrix
colnames(comat)<-paste("H", 1:nrow(comat), sep = "")
rownames(comat)<-paste("H", 1:nrow(comat), sep = "")
heatmap(comat,scale="none",col=heat.colors(100),keep.dendro=TRUE, symm=TRUE) #stats package

comat
```


Haploytype network- individuals
```{r}
library(pegas)
h<-pegas::haplotype(d, strict = FALSE, trailingGapsAsN = TRUE)#extracts haplotypes from DNAbin object
hname<-paste("H", 1:nrow(h), sep = "")
rownames(h)= paste(hname)
net<-haploNet(h, d = NULL, getProb = TRUE)#constructs the haplotype network
net
ind.hap<-with(
    utils::stack(setNames(attr(h, "index"), rownames(h))),
    table(hap=ind, individuals=rownames(d))
)

par(mar=c(0.01,0.01,0.01,15))
plot(net, size=attr(net, "freq"), scale.ratio = 2, cex = 0.6, labels=TRUE, pie = ind.hap, show.mutation=1, font=2, fast=TRUE)
legend(x= 57,y=15, colnames(ind.hap), fill=rainbow(ncol(ind.hap)), cex=0.52, ncol=6, x.intersp=0.2, text.width=11)
```

```{r}
h<-pegas::haplotype(d, strict = FALSE, trailingGapsAsN = TRUE)#extracts haplotypes from DNAbin object
hname<-paste("H", 1:nrow(h), sep = "")
rownames(h)= paste(hname)
net<-haploNet(h, d = NULL, getProb = TRUE) #constructs the haplotype network
net
ind.hap<-with(
    utils::stack(setNames(attr(h, "index"), rownames(h))),
    table(hap=ind, individuals=rownames(d)[values])
)

#We followed the name order in the ind.hap object for all coloring of samples in the haplotype network circles.
#You can see the order of sample names using the command "colnames(ind.hap)".
#The color of the samples has been assigned as the "bg" list for use in the plot () command, as below.
#The number of colors is determined by the number of samples in the same population (see "colnames (ind.hap)").
#Using the colors() command, you can choose different colors for your samples according to the populations.

bg<-c(rep("dodgerblue4", 15), rep("olivedrab4",15), rep("royalblue2", 15), rep("red",15), rep("olivedrab3",15), 
 rep("skyblue1", 15), rep("olivedrab1", 15),  rep("darkseagreen1", 15))

#If you are not going to use a special order for the population names to be listed in the legend command (population names listed in the legend ("hapcol"), 
#you can automatically select and sort the population names using the following command ("sn2"). 
#This order is fully consistent with the order in the ind.hap object.

#un2<-unique(n2)
#sn2<-sort(un2)

#Then you must the use "sn2" list instead of "hapcol" list in the legend argument.

#But, we wanted to order names of the population names according to groups. 
#Therefore, we reordered the population names as "hapcol" list.
#So, you can see color transitions of the populations by the groups. 
#The population names were assigned using "hapcol" list in the legend () command.

hapcol<-c("Aksu", "Demre", "Kumluca", "Firm", "Bayatbadem", "Geyikbayir", "Phaselis", "Termessos")

#At this point, the colors to be used in the list where the populations will be shown (legend) must match the colors you choose for the samples in the circles.
#Therefore, if you used the "sn2" list, you can directly use the "bg" list for the populations' color symbols. 
#Note, now the number of colors must be changed to "1" for each population.
#For example;
#bgp<-c(rep("dodgerblue4", 1), rep("olivedrab4",1),...)

#Then you must the use "bgp" list instead of "ubg" list in the legend argument (fill).

#But, we used different order for the population names (hapcol list).
#Thus, colors of the population were assigned as "ubg" list and used in the fill argument of the legend () command.
#The colors of the samples assigned in the bg list and the population colors (ubg) belonging samples must match each other.

ubg<-c(rep("dodgerblue4",1), rep("royalblue2",1), rep("skyblue1",1), rep("red",1), rep("olivedrab4",1), 
rep("olivedrab3",1), rep("olivedrab1",1), rep("darkseagreen1",1))

par(mar=c(0.001,0.001,0.001,0.001))
plot(net, size=attr(net, "freq"), bg = bg, scale.ratio = 2, cex = 0.7, labels=TRUE, pie = ind.hap, show.mutation=1, font=2, fast=TRUE)
legend(x=-36,y=53, hapcol, fill=ubg, cex=0.8, ncol=1, bty="n", x.intersp = 0.2)
```