---
title: "DNA Sequence Data and Phylogenetics"
author: "Alexandra Boville"
date: "2024-04-24"
output: html_document
---

## Starting Steps: Reading in DNA Code and Preliminary Data

### Load in Necessary Packages
```{r}
InstallPackages = FALSE
if (InstallPackages) {
    if (!requireNamespace("BiocManager", quietly=TRUE)) 
        install.packages("BiocManager")
    BiocManager::install("msa")
    install.packages("adegenet")
    install.packages("ape")
    BiocManager::install("Biostrings")
    BiocManager::install("ggtree")
    install.packages("ggplot2")
    install.packages("ips")
    install.packages("bios2mds")
    install.packages("haplotypes")
    install.packages("pegas")
    install.packages("phytools")
    install.packages("stats")
    install.packages("treeio") }
```

```{r}
library(adegenet)
library(ape)
library(Biostrings)
library(ggtree)
library(ggplot2)
library(stats)
library(ips)
library(msa)
library (spider)
```
### Read in DNA Code
```{r}
Rhea_dna <- read.dna("https://raw.githubusercontent.com/allyboville3/Collaborative-Data-Science-Project/main/Aves%20FASTA%20Files/Rhea_americana.fasta", format = "fasta")

# This creates a specific structure called a DNAbin in {ape}. We can see this by checking the class.

class (Rhea_dna)
```

### Preliminary data/looking

Use {pegas} to gather some other information:
This calculates the frequency of the four nucleotides in the FASTA file
```{r}
base.freq(Rhea_dna)
```

This calculates the GC content, which is useful in ancient DNA. 
```{r}
GC.content(Rhea_dna)
```

## Trimming and Preparing Data

```{r}
MySeq <- readDNAStringSet("https://raw.githubusercontent.com/allyboville3/Collaborative-Data-Science-Project/main/Aves_cytB.fas")
```

Using the `msa()` function in the {msa} package aligns all samples to the same length by the ClustalW algorithm and stores them as a DNAStringSet object.
```{r}
msa(MySeq)
```
Let's look at it!
```{r}
print(MySeq)
```

Using the `as.DNAbin()` function from {ape} allows us to store these multiple alignments as a DNAbin object. We need a DNAbin object going forward to use many functions, including those from {ape}
```{r}
SeqBin <- as.DNAbin(MySeq)
```

Trim ends?
```{r}
SeqBin <- trimEnds(as.matrix(SeqBin))
```


## Phylogenetics

```{r}
#remove partial genome C.bennetti from matrix because is not the same length (in # of bp) as other sequences

nbinmat<-as.matrix(labels(SeqBin)) #extraction of the sample names
SeqBin
class(SeqBin)
dnbin<-dist.dna(SeqBin, model = "K80") #computing distance by ape package with K80 model derived by Kimura (1980)
tree<-nj(dnbin)
```

Plot a phylogenetic tree using the `msaplot()` command from {ggtree} along with various aesthetics from {ggplot2}
```{r}
ggt <- ggtree(tree, cex = 0.8, aes(color = branch.length)) +
  scale_color_continuous(high = "coral",low = "black") +
  geom_tiplab(align = TRUE, size = 7) +
  theme(legend.position = "right") +
  geom_treescale(y = -5, color = "coral4", fontsize = 4)
  msaplot(ggt, SeqBin, offset = 0.15, width = 1, height = 0.5)
  
  
    #color = c(rep("rosybrown", 1), rep("sienna1", 1),
    #rep("lightgoldenrod1", 1), rep("lightskyblue1", 1), rep("green", 1))
    )
  

ggtree(tree, aes(color = branch.length)) + geom_tiplab(size = 7) + layout_inward_circular()


```
There are other ways to represent trees that show different things:

INSERT THE WORK ON OTHER PHYLOGENIES HERE

## More analysis
Calculating Genetic Distance demonstrates that our assumption that the unknown is most closely related to *Dinornis giganteus* is correct. 
```{r}
dist.gene((as.matrix(SeqBin)), method = "pairwise", pairwise.deletion = FALSE,
          variance = FALSE)
```
Monophyletic

```{r}
is.monophyletic(tree, c("Dinornis giganteus", "Unknown Species"))
is.monophyletic(tree, c("Dinornis giganteus", "Struthio camelus"))

```


## Tree Rooting

```{r}
# plot tree
plot.phylo(tree, main="Aves (Palaeognathae) Phylogenetic Tree", 
            type = "unrooted", 
            use.edge.length = F)

# add label
mtext(text = "Unrooted Tree - No branch Lengths")
```

```{r}
# plot tree
plot.phylo(tree, main= "Aves (Palaeognathae) Phylogenetic Tree", 
            use.edge.length = F)

# add label
mtext(text = "Rooted Tree - No branch Lengths")
```


```{r}
# plot tree
plot.phylo(tree, main="Aves (Palaeognathae) Phylogenetic Tree", 
            use.edge.length = T)

# add label
mtext(text = "Rooted Tree - With Branch Lengths")
```



## Haplotypes and Heatmaps

We used the data from the original paper, because the above data covered multiple species and was not appropriate for haplotype studies. 
```{r}
d <- read.dna("https://raw.githubusercontent.com/electrickearns/ada-2024-notes/main/pone.0243927.s002.fas", format = "fas")
class(d)
```

After, 

```{r}
an<-as.alignment(d)  #converting DNAbin to alignment format
nm<-as.matrix(an)       #converting alignment to matrix
sat2 <- NULL
for (i in 1:nrow(nm)) {
  sat2[i] <- paste(nm[i, ], collapse="")
}

sat2 <- toupper(sat2) #converts all letters to uppercase
sat3 <- unique(sat2) #gives only unique sequences from all sequences
sat3#that is, it gives complete sequences of haplotypes (20x373).
hfreq <- NULL
for (i in 1:length(sat3)) {
  hcount = 0
  s3 <- sat3[i]
  for (j in 1:length(sat2)) {
    s2 <- sat2[j]
    if (s3 == s2) {
      hcount <- (hcount + 1) #counts the number of individuals with the same haplotype sequence. 
      #print(paste(i, "yes", hcount))
    }
    #print(s2)
  }
  hname<-(paste("H",i, sep =""))
  hfreq[i] <- hcount
  #print(paste(hname, hcount, collapse = ""))
}   #haplotype frequency in the all samples

len <- nchar(sat3[1]) #assume all have same length!!!
cnt <- 1
sat4 = list()
for (j in 1:len) {
  same <- TRUE
  first <- substr(sat3[1], j, j)
  for (i in 2:length(sat3)) {
    ch1 <- substr(sat3[i], j, j)
    if (first != ch1) {
      str <- paste(j, first, ch1)
      print(str)
      same <- FALSE
      break
    }
  }
  if (!same) {
    ss <- NULL
    for (i in 1:length(sat3)) {
      ss <- paste(ss, substr(sat3[i], j, j), sep="")
    }
    sat4[cnt] <- ss
    cnt <- cnt + 1
  }
}#it gives the mutation points and the nucleotide substitutions

len <- nchar(sat3[1]) #assume all have same length!!!
cnt <- 1
sat5 = list() 
for (j in 1:len) { #scan all columnns and if all elements are the same do not copy
  same <- TRUE
  first <- substr(sat3[1], j, j)
  scol <- first
  for (i in 2:length(sat3)) {
    ch1 <- substr(sat3[i], j, j)
    scol <- paste(scol, ch1, sep="")
    if (first != ch1) {
      str <- paste(j, first, ch1)
      #print(str)
      same <- FALSE
      #break
    }
  }
  if (!same) {
    scol <- paste("V_", cnt, " ", scol, sep="")
    ss <- NULL
    for (i in 1:length(sat3)) {
      ss <- paste(ss, substr(sat3[i], j, j), sep="")
    } 
    sat5[cnt] <- ss
    cnt <- cnt + 1
  }
}

sat6 <- as.matrix(sat5)
mat6 = matrix(nrow=nrow(sat6), ncol=nchar(sat6[1]))
for (i in 1:nrow(mat6)) {
  s <- as.vector(strsplit(as.character(sat5[i]), ""))
  for (j in 1:ncol(mat6)) {
    mat6[i, j] <- as.character(s[[1]][j])
  }
}
mat7 <- t(mat6) #sequences of haplotypes and variable sites matrix (20x41)
write.table(mat7,file="mat7.txt", quote=FALSE, sep="\t")
hname<-paste("H", 1:nrow(mat7), sep = "")
rownames(mat7)=hname
write.table(mat7,file="mat7.txt", quote=FALSE, sep="\t") 

str4 <- NULL
str4[1] <- paste(mat7[1, ], collapse="")
for (i in 2:nrow(mat7)) {
  tmp <- NULL
  for (j in 1:ncol(mat7)) {
    chr = "."
    if(mat7[i, j] != mat7[1, j]) chr = mat7[i, j]
    tmp <- paste(tmp, chr, sep="")
  }
  str4[i] <- paste(tmp, collapse="")
}
nchar(str4[1]) #confirmation of number of variable sites
mstr4<-as.matrix(str4)
rownames(mstr4)<-hname
colnames(mstr4)<-paste("sequences length","(", ncol(mat7), "base pairs", ")")
pct<-round((as.matrix(hfreq)*100/colSums(as.matrix(hfreq))), 2)
colnames(pct)<-c("pct")
cmstr4<-as.data.frame(cbind(mstr4, hfreq, pct))
cmstr4
write.table(cmstr4,file="cmstr4.txt", quote=FALSE, sep="\t") 
```


Create the heatmap!
```{r}
sat2 <- NULL
for (i in 1:nrow(nm)) {
  sat2[i] <- paste(nm[i, ], collapse="")
}

sat2 <- toupper(sat2)
sat3 <- unique(sat2)
comat = matrix(nrow=length(sat3), ncol=length(sat3))
for (i in 1:length(sat3)) { 
  si <- sat3[i]
  for (j in 1:length(sat3)) { 
    sj <- sat3[j]
    difcnt = 0
    s1 = as.vector(strsplit(as.character(si), ""))
    s2 = as.vector(strsplit(as.character(sj), ""))
    for (k in 1:length(s1[[1]])) {
      if (s1[[1]][k] != s2[[1]][k]) {
        difcnt = difcnt + 1
      }
      comat[i, j] = difcnt
      #print(paste(i, " ", j, " ", difcnt))
    }
  }
}
comat	#is Hamming distance matrix
colnames(comat)<-paste("H", 1:nrow(comat), sep = "")
rownames(comat)<-paste("H", 1:nrow(comat), sep = "")
heatmap(comat,scale="none",col=heat.colors(100),keep.dendro=TRUE, symm=TRUE) #stats package

comat
```


Haploytype network- individuals
```{r}
library(pegas)
h<-pegas::haplotype(d, strict = FALSE, trailingGapsAsN = TRUE)#extracts haplotypes from DNAbin object
hname<-paste("H", 1:nrow(h), sep = "")
rownames(h)= paste(hname)
net<-haploNet(h, d = NULL, getProb = TRUE)#constructs the haplotype network
net
ind.hap<-with(
    utils::stack(setNames(attr(h, "index"), rownames(h))),
    table(hap=ind, individuals=rownames(d))
)

par(mar=c(0.01,0.01,0.01,15))
plot(net, size=attr(net, "freq"), scale.ratio = 2, cex = 0.6, labels=TRUE, pie = ind.hap, show.mutation=1, font=2, fast=TRUE)
legend(x= 57,y=15, colnames(ind.hap), fill=rainbow(ncol(ind.hap)), cex=0.52, ncol=6, x.intersp=0.2, text.width=11)
```

```{r}
h<-pegas::haplotype(d, strict = FALSE, trailingGapsAsN = TRUE)#extracts haplotypes from DNAbin object
hname<-paste("H", 1:nrow(h), sep = "")
rownames(h)= paste(hname)
net<-haploNet(h, d = NULL, getProb = TRUE) #constructs the haplotype network
net
ind.hap<-with(
    utils::stack(setNames(attr(h, "index"), rownames(h))),
    table(hap=ind, individuals=rownames(d)[values])
)

#We followed the name order in the ind.hap object for all coloring of samples in the haplotype network circles.
#You can see the order of sample names using the command "colnames(ind.hap)".
#The color of the samples has been assigned as the "bg" list for use in the plot () command, as below.
#The number of colors is determined by the number of samples in the same population (see "colnames (ind.hap)").
#Using the colors() command, you can choose different colors for your samples according to the populations.

bg<-c(rep("dodgerblue4", 15), rep("olivedrab4",15), rep("royalblue2", 15), rep("red",15), rep("olivedrab3",15), 
 rep("skyblue1", 15), rep("olivedrab1", 15),  rep("darkseagreen1", 15))

#If you are not going to use a special order for the population names to be listed in the legend command (population names listed in the legend ("hapcol"), 
#you can automatically select and sort the population names using the following command ("sn2"). 
#This order is fully consistent with the order in the ind.hap object.

#un2<-unique(n2)
#sn2<-sort(un2)

#Then you must the use "sn2" list instead of "hapcol" list in the legend argument.

#But, we wanted to order names of the population names according to groups. 
#Therefore, we reordered the population names as "hapcol" list.
#So, you can see color transitions of the populations by the groups. 
#The population names were assigned using "hapcol" list in the legend () command.

hapcol<-c("Aksu", "Demre", "Kumluca", "Firm", "Bayatbadem", "Geyikbayir", "Phaselis", "Termessos")

#At this point, the colors to be used in the list where the populations will be shown (legend) must match the colors you choose for the samples in the circles.
#Therefore, if you used the "sn2" list, you can directly use the "bg" list for the populations' color symbols. 
#Note, now the number of colors must be changed to "1" for each population.
#For example;
#bgp<-c(rep("dodgerblue4", 1), rep("olivedrab4",1),...)

#Then you must the use "bgp" list instead of "ubg" list in the legend argument (fill).

#But, we used different order for the population names (hapcol list).
#Thus, colors of the population were assigned as "ubg" list and used in the fill argument of the legend () command.
#The colors of the samples assigned in the bg list and the population colors (ubg) belonging samples must match each other.

ubg<-c(rep("dodgerblue4",1), rep("royalblue2",1), rep("skyblue1",1), rep("red",1), rep("olivedrab4",1), 
rep("olivedrab3",1), rep("olivedrab1",1), rep("darkseagreen1",1))

par(mar=c(0.001,0.001,0.001,0.001))
plot(net, size=attr(net, "freq"), bg = bg, scale.ratio = 2, cex = 0.7, labels=TRUE, pie = ind.hap, show.mutation=1, font=2, fast=TRUE)
legend(x=-36,y=53, hapcol, fill=ubg, cex=0.8, ncol=1, bty="n", x.intersp = 0.2)
```